diff --git a/matplotlibcpp.h b/matplotlibcpp.h
index d95d46a..c87a422 100644
--- a/matplotlibcpp.h
+++ b/matplotlibcpp.h
@@ -73,6 +73,7 @@ struct _interpreter {
     PyObject *s_python_function_ion;
     PyObject *s_python_function_ginput;
     PyObject *s_python_function_ylim;
+    PyObject *s_python_function_clim;
     PyObject *s_python_function_title;
     PyObject *s_python_function_axis;
     PyObject *s_python_function_axhline;
@@ -247,6 +248,7 @@ private:
         s_python_function_legend = safe_import(pymod, "legend");
         s_python_function_xlim = safe_import(pymod, "xlim");
         s_python_function_ylim = safe_import(pymod, "ylim");
+        s_python_function_clim = safe_import(pymod, "clim");
         s_python_function_title = safe_import(pymod, "title");
         s_python_function_axis = safe_import(pymod, "axis");
         s_python_function_axhline = safe_import(pymod, "axhline");
@@ -350,10 +352,10 @@ template <> struct select_npy_type<uint64_t> { const static NPY_TYPES type = NPY

 // Sanity checks; comment them out or change the numpy type below if you're compiling on
 // a platform where they don't apply
-static_assert(sizeof(long long) == 8);
-template <> struct select_npy_type<long long> { const static NPY_TYPES type = NPY_INT64; };
-static_assert(sizeof(unsigned long long) == 8);
-template <> struct select_npy_type<unsigned long long> { const static NPY_TYPES type = NPY_UINT64; };
+// static_assert(sizeof(long long) == 8);
+// template <> struct select_npy_type<long long> { const static NPY_TYPES type = NPY_INT64; };
+// static_assert(sizeof(unsigned long long) == 8);
+// template <> struct select_npy_type<unsigned long long> { const static NPY_TYPES type = NPY_UINT64; };

 template<typename Numeric>
 PyObject* get_array(const std::vector<Numeric>& v)
@@ -957,6 +959,11 @@ inline void imshow(const float *ptr, const int rows, const int columns, const in
     detail::imshow((void *) ptr, NPY_FLOAT, rows, columns, colors, keywords, out);
 }

+inline void imshow(const double *ptr, const int rows, const int columns, const int colors, const std::map<std::string, std::string> &keywords = {}, PyObject** out = nullptr)
+{
+    detail::imshow((void *) ptr, NPY_DOUBLE, rows, columns, colors, keywords, out);
+}
+
 #ifdef WITH_OPENCV
 void imshow(const cv::Mat &image, const std::map<std::string, std::string> &keywords = {})
 {
@@ -2025,6 +2032,25 @@ inline void set_aspect_equal()
     Py_DECREF(kwargs);
 }

+template<typename Numeric>
+void clim(Numeric left, Numeric right)
+{
+    detail::_interpreter::get();
+
+    PyObject* list = PyList_New(2);
+    PyList_SetItem(list, 0, PyFloat_FromDouble(left));
+    PyList_SetItem(list, 1, PyFloat_FromDouble(right));
+
+    PyObject* args = PyTuple_New(1);
+    PyTuple_SetItem(args, 0, list);
+
+    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_clim, args);
+    if(!res) throw std::runtime_error("Call to clim() failed.");
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+}
+
 template<typename Numeric>
 void ylim(Numeric left, Numeric right)
 {
@@ -2093,6 +2119,20 @@ inline std::array<double, 2> ylim()
     return { PyFloat_AsDouble(left), PyFloat_AsDouble(right) };
 }

+inline std::array<double, 2> clim()
+{
+    PyObject* args = PyTuple_New(0);
+    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_clim, args);
+
+    if(!res) throw std::runtime_error("Call to clim() failed.");
+
+    Py_DECREF(res);
+
+    PyObject* left = PyTuple_GetItem(res,0);
+    PyObject* right = PyTuple_GetItem(res,1);
+    return { PyFloat_AsDouble(left), PyFloat_AsDouble(right) };
+}
+
 template<typename Numeric>
 inline void xticks(const std::vector<Numeric> &ticks, const std::vector<std::string> &labels = {}, const std::map<std::string, std::string>& keywords = {})
 {
