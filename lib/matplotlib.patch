diff --git a/matplotlibcpp.h b/matplotlibcpp.h
index d95d46a..031690e 100644
--- a/matplotlibcpp.h
+++ b/matplotlibcpp.h
@@ -11,6 +11,7 @@
 #include <algorithm>
 #include <stdexcept>
 #include <iostream>
+#include <sstream>
 #include <cstdint> // <cstdint> requires c++11 support
 #include <functional>
 #include <string> // std::stod
@@ -73,6 +74,7 @@ struct _interpreter {
     PyObject *s_python_function_ion;
     PyObject *s_python_function_ginput;
     PyObject *s_python_function_ylim;
+    PyObject *s_python_function_clim;
     PyObject *s_python_function_title;
     PyObject *s_python_function_axis;
     PyObject *s_python_function_axhline;
@@ -247,6 +249,7 @@ private:
         s_python_function_legend = safe_import(pymod, "legend");
         s_python_function_xlim = safe_import(pymod, "xlim");
         s_python_function_ylim = safe_import(pymod, "ylim");
+        s_python_function_clim = safe_import(pymod, "clim");
         s_python_function_title = safe_import(pymod, "title");
         s_python_function_axis = safe_import(pymod, "axis");
         s_python_function_axhline = safe_import(pymod, "axhline");
@@ -350,10 +353,10 @@ template <> struct select_npy_type<uint64_t> { const static NPY_TYPES type = NPY

 // Sanity checks; comment them out or change the numpy type below if you're compiling on
 // a platform where they don't apply
-static_assert(sizeof(long long) == 8);
-template <> struct select_npy_type<long long> { const static NPY_TYPES type = NPY_INT64; };
-static_assert(sizeof(unsigned long long) == 8);
-template <> struct select_npy_type<unsigned long long> { const static NPY_TYPES type = NPY_UINT64; };
+// static_assert(sizeof(long long) == 8);
+// template <> struct select_npy_type<long long> { const static NPY_TYPES type = NPY_INT64; };
+// static_assert(sizeof(unsigned long long) == 8);
+// template <> struct select_npy_type<unsigned long long> { const static NPY_TYPES type = NPY_UINT64; };

 template<typename Numeric>
 PyObject* get_array(const std::vector<Numeric>& v)
@@ -931,7 +934,42 @@ inline void imshow(void *ptr, const NPY_TYPES type, const int rows, const int co
     PyObject* kwargs = PyDict_New();
     for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
     {
-        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
+        if (it->first == "extent")
+        {
+            const auto split = [](const std::string& value, const char delimiter)
+            {
+              std::vector<std::string> values;
+
+              std::stringstream lines(value);
+              std::string line;
+
+              while (std::getline(lines, line, delimiter))
+              {
+                values.push_back(line);
+              }
+
+              return values;
+            };
+
+            const auto values = split(it->second, ',');
+
+            PyObject* extent = PyList_New(4);
+
+            for (size_t i = 0; i < (std::min)(values.size(), size_t(4)); ++i)
+            {
+                const double value = std::stod(values.at(i));
+
+                PyList_SetItem(extent, i, PyFloat_FromDouble(value));
+            }
+
+            PyDict_SetItemString(kwargs, "extent", extent);
+
+            Py_DECREF(extent);
+        }
+        else
+        {
+            PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
+        }
     }

     PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_imshow, args, kwargs);
@@ -957,6 +995,11 @@ inline void imshow(const float *ptr, const int rows, const int columns, const in
     detail::imshow((void *) ptr, NPY_FLOAT, rows, columns, colors, keywords, out);
 }

+inline void imshow(const double *ptr, const int rows, const int columns, const int colors, const std::map<std::string, std::string> &keywords = {}, PyObject** out = nullptr)
+{
+    detail::imshow((void *) ptr, NPY_DOUBLE, rows, columns, colors, keywords, out);
+}
+
 #ifdef WITH_OPENCV
 void imshow(const cv::Mat &image, const std::map<std::string, std::string> &keywords = {})
 {
@@ -1847,7 +1890,7 @@ void text(Numeric x, Numeric y, const std::string& s = "")
     Py_DECREF(res);
 }

-inline void colorbar(PyObject* mappable = NULL, const std::map<std::string, float>& keywords = {})
+inline void colorbar(PyObject* mappable = NULL, const std::map<std::string, float>& keywords = {}, PyObject** out = nullptr)
 {
     if (mappable == NULL)
         throw std::runtime_error("Must call colorbar with PyObject* returned from an image, contour, surface, etc.");
@@ -1864,14 +1907,43 @@ inline void colorbar(PyObject* mappable = NULL, const std::map<std::string, floa
     }

     PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_colorbar, args, kwargs);
-    if(!res) throw std::runtime_error("Call to colorbar() failed.");
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    if (!res)
+        throw std::runtime_error("Call to colorbar() failed.");
+    if (out)
+        *out = res;
+    else
+        Py_DECREF(res);
+}
+
+inline void colorbar_set_label(PyObject* colorbar, const std::string& value)
+{
+    PyObject* set_label = PyObject_GetAttrString(colorbar, "set_label");
+
+    if (!set_label)
+      throw std::runtime_error("Attribute set_label not found.");
+
+    Py_INCREF(set_label);
+
+    PyObject* args = PyTuple_New(1);
+    PyObject* kwargs = PyDict_New();
+
+    PyTuple_SetItem(args, 0, PyUnicode_FromString(value.c_str()));
+
+    PyObject* res = PyObject_Call(set_label, args, kwargs);

     Py_DECREF(args);
     Py_DECREF(kwargs);
+
+    Py_DECREF(set_label);
+
+    if (!res)
+      throw std::runtime_error("Call colorbar set_label failed.");
+
     Py_DECREF(res);
 }

-
 inline long figure(long number = -1)
 {
     detail::_interpreter::get();
@@ -2025,6 +2097,25 @@ inline void set_aspect_equal()
     Py_DECREF(kwargs);
 }

+template<typename Numeric>
+void clim(Numeric left, Numeric right)
+{
+    detail::_interpreter::get();
+
+    PyObject* list = PyList_New(2);
+    PyList_SetItem(list, 0, PyFloat_FromDouble(left));
+    PyList_SetItem(list, 1, PyFloat_FromDouble(right));
+
+    PyObject* args = PyTuple_New(1);
+    PyTuple_SetItem(args, 0, list);
+
+    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_clim, args);
+    if(!res) throw std::runtime_error("Call to clim() failed.");
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+}
+
 template<typename Numeric>
 void ylim(Numeric left, Numeric right)
 {
@@ -2093,6 +2184,20 @@ inline std::array<double, 2> ylim()
     return { PyFloat_AsDouble(left), PyFloat_AsDouble(right) };
 }

+inline std::array<double, 2> clim()
+{
+    PyObject* args = PyTuple_New(0);
+    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_clim, args);
+
+    if(!res) throw std::runtime_error("Call to clim() failed.");
+
+    Py_DECREF(res);
+
+    PyObject* left = PyTuple_GetItem(res,0);
+    PyObject* right = PyTuple_GetItem(res,1);
+    return { PyFloat_AsDouble(left), PyFloat_AsDouble(right) };
+}
+
 template<typename Numeric>
 inline void xticks(const std::vector<Numeric> &ticks, const std::vector<std::string> &labels = {}, const std::map<std::string, std::string>& keywords = {})
 {
